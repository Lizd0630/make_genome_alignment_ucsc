#!/bin/bash

# This file is to run lastz/chain tasks in an task array

# This file is generated by following the example at
# http://genomewiki.ucsc.edu/images/9/93/RunLastzChain_sh.txt

# stop if error
set -e

run_lastz=$(dirname $0)/run_lastz.sbc
#echo $run_lastz

echo -e "\n"
echo '****************************************************'
echo Edit necessary parameters before running this script
echo This script can read into two genome sequences in .2bit
echo format, and align them with lastz and chained with
echo axtChain. It will also call a job arrays to run 
echo alignment in a computer cluster. See $run_lastz
echo for cluster settings.
echo ''
echo Usage: $0 '<T-name> <Q-name>' [go]
echo T-name and Q-name are basenames of .2bit files for target
echo and query sequences, respectively. If 'go' is not given,
echo the program will confirm with you before proceeding.
echo ''
echo Note: the folders chain/ psl/ raw/ and tmp/ in current
echo folder will be overwritten.
echo '****************************************************'
echo ''

if [[ ! -f $run_lastz ]]; then
	echo "Can not find $run_lastz, which must be in the same \
	directory as $0"
	exit 1;
fi

if [[ $# < 2 ]]; then
	echo -e "Not enough arguments are found. Check usage\n"
	exit 1;
fi


export TNAME=$1 # target genome name, must be consistent with TNAME.2bit
export QNAME=$2 # same for query genome
export TARGET=${TNAME}.2bit # sequence files
export QUERY=${QNAME}.2bit

if [[ (! -f $TARGET) || (! -f $QUERY) ]]; then
	echo -e "Can not see $TARGET or $QUERY. Please check usage\n"
	exit 1;
fi

if [[ ! $3 ]]; then
	echo This progrom is going to run lastz on genomes [$TNAME vs \
	$QNAME]. Are you sure [Y/N]?
	read -t 60 go
	if [[ ! $go =~ ^[Yy] ]]; then
		exit 1
	fi
fi

echo Started at `date`
source $UCSC_CONFIG_DIR/settings.chainNet # get $lastzDros and
# $chainDros
mkdir -p logs

# setup variables, visible by called sub-programs
#************************************#
# ****** Editable parameters ******* #
export lastzParams="$lastzDros" # parameters for lastz
export chainParams="$chainDros" # parameters for axtChain

echo chainParams="$chainDros"
echo lastzParams="$lastzDros"


 # parameters controlling how genomes are split for easier alignment
tChunk=20000000 # target chunk size
tLap=10000 # overlap among target chunks
qChunk=20000000 # query chunk
qLap=0
#ls -ld $TARGET $QUERY

# ******* End of Editable parameters * #
#************************************#

echo Preparing lastz/chain running on $TNAME vs $QNAME

module load UCSC
module load lastz/1.03.46 # lastz/1.02.00 only support M < 255
rm -rf chain psl raw tmp
mkdir chain psl raw tmp # dirs for storing the data

# generate the chromosizes if not available
if [ ! -s ${TNAME}.chrom.sizes ]; then
	twoBitInfo $TARGET stdout | sort -k2nr >$TNAME.chrom.sizes
	rm -rf ${TNAME}PartList ${TNAME}.part.list
	mkdir  ${TNAME}PartList
fi

if [ ! -s ${QNAME}.chrom.sizes ]; then
	twoBitInfo $QUERY stdout | sort -k2nr >${QNAME}.chrom.sizes
	rm -rf ${QNAME}PartList ${QNAME}.part.list
	mkdir ${QNAME}PartList
fi

# split target sequences into 10M-long chunks with 10K overlap, and
# ${TNAME}PartList stores the lumpped small sequences
if [ ! -s ${TNAME}.part.list ]; then
	partitionSequence.pl $tChunk $tLap ${TARGET} ${TNAME}.chrom.sizes \
	1 -lstDir ${TNAME}PartList > ${TNAME}.part.list
fi

# split query sequences into 20M-long chunks without overlap
if [ ! -s ${QNAME}.part.list ]; then
	partitionSequence.pl $qChunk $qLap ${QUERY} ${QNAME}.chrom.sizes 1 \
	-lstDir ${QNAME}PartList > ${QNAME}.part.list
fi

# generate target.list file, which contains the sequence segments in
# .2bit format, such as dm3.2bit:chr3R:10000000-20010000
grep -v PartList ${TNAME}.part.list > target.list
for F in ${TNAME}PartList/*.lst
do
	cat ${F}
done >> target.list

# generate query.list file
grep -v PartList ${QNAME}.part.list > query.list
for F in ${QNAME}PartList/*.lst
do
	cat ${F}
done >> query.list

# generate the liftup file for later converting coordinates back. Run
# 'liftUp' without parameter to see the format of the liftup file
constructLiftFile.pl ${TNAME}.chrom.sizes target.list > target.lift
constructLiftFile.pl ${QNAME}.chrom.sizes query.list > query.lift

# get the number of chunks in target and query
tNum=`wc -l target.lift | cut -f 1 -d ' '`
qNum=`wc -l query.lift | cut -f 1 -d ' '`

# get task array size
arraySize=$(( $tNum * $qNum ));

# let us generate input files for task arrays
tCounter=0
qCounter=0
inFile=tmp/task_input
if [[ -e $inFile ]]; then
	rm $inFile
fi

echo "Making fasta chunks\n"
for tSeg in `cat target.list`
do
	(( tCounter += 1 )) # DO NOT use (( tCounter++ ))
	tFa=tmp/T$tCounter.fa # generate fasta files in the main script
	twoBitToFa $tSeg $tFa
	qCounter=0
	for qSeg in `cat query.list`
	do
		(( qCounter += 1 ));
		qFa=tmp/Q$qCounter.fa
		if [[ ! -s $qFa ]]; then
			twoBitToFa $qSeg $qFa
		fi
		counter=${tCounter}_${qCounter}
		echo -e "$counter\t$tFa\t$qFa" >>$inFile
	done
done

echo Starting $arraySize jobs in a job array;

sbatch -a 1-$arraySize $run_lastz

#rm tmp/*.fa
#rmdir --ignore-fail-on-non-empty tmp

wait; # this does not work here, because sbatch return immediately

# we can do merge later
# now let us merge the chain together
#find ./chain -name "*.chain" | chainMergeSort -inputList=stdin \
#| gzip -c > ${TNAME}.${QNAME}.all.chain.gz

echo Ended at `date`

exit 0;

